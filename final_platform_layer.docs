// ****************************************************************************
//
// Documentation
//
// ****************************************************************************

/*!
	\mainpage
	\tableofcontents

	\section section_overview Overview

	Final Platform Layer is a Single-Header-File cross-platform C development library designed to abstract the underlying platform to a simple and easy to use api - providing low level access to (Window, Video, Audio, Input, File/Path IO, Threads, Memory, Hardware, etc.).<br>
	<br>
	The main focus is game/media/simulation development, so the default settings will create a window, setup a OpenGL rendering context and initialize audio playback on any platform.<br>
	<br>
	FPL supports the platforms Windows/Linux/Unix for the architectures x86/x64.<br>
	The only dependencies are built-in operating system libraries and a C99 complaint compiler.<br>
	<br>
	It is released under the \subpage page_license "MIT License". This license allows you to use FPL freely in any software.<br>

	\section section_using_this_documentation How to use this documentation?
	Use the following links to learn more about FPL:
	- \subpage page_introduction
	- \subpage page_usage
	- \subpage page_tutorials
	- \subpage page_examples
	- \subpage page_faq
	- \subpage page_contribute
	- \subpage page_changelog
	- \subpage page_todo
	- \subpage page_license

	I hope you find all the informations you need. If not please drop a issue on the github project page and i address it as soon as possible!

	Thanks for using, have a great day!
*/

/*!
	\page page_introduction Introduction
	\tableofcontents

	\section section_intro Introduction to FPL

	\subsection subsection_whatisfpl What is FPL?

	Final Platform Layer is a Single-Header-File cross-platform C development library designed to abstract the underlying platform to a very simple and easy to use api - providing low level access to:<br>
	- Single Window creation and handling
	- Graphics Software or Hardware Rendering initialization.
	- Playback of raw Audio Samples
	- Accessing Input Devices (Keyboard, Mouse, Gamepad)
	- IO handling (Files, Directories, Paths)
	- Multithreading (Threads, Mutexes, Signals, Conditions)
	- Allocating Memory
	- Retrieve Hardware & OS Informations
	
	The main focus is game/media/simulation development, so the default settings will create a window, setup a OpenGL rendering context and initialize audio playback on any platform.<br>
	<br>
	Final Platform Layer is released under the \subpage page_license "MIT License". This license allows you to use FPL freely in any software.<br>

	\subsection subsection_whatissingleheaderfilelibrary What is a single-header-file Library and why is FPL based on that?
	A single header file library (as the name implies) is a development library designed to be one file only.<br>
	Such a file contains the header (API) and the body (Implementation) in one file but separated and controlled by compiler conditions.<br>
	This makes it easy to use the library however you want (With source, Static-linked, Private use only).<br>
	In addition such libraries mostly does not require any dependencies at all, to making it more friendly to the user.<br>
	<br>
	So, why then is FPL based on that?<br>
	<br>
	Because non-single-header-file libraries are either hard to integrate, forces you to link to it dynamically or statically, are closed source, comes with a ton of dependencies - which is not user friendly at all!

	\subsection subsection_supported_platforms Which platforms are supported by FPL?
	Right know FPL supports just a couple of x86/x64 platforms, but some are already in progress and more are planned:

	- Windows (x86/x64)
	- Linux (x86/x64, Partially)
	- Unix (x86/x64, Partially)

	For more details see the page: \subpage page_platform_status
	
	\subsection subsection_supported_compilers Which compilers are supported by FPL?
	FPL should compile on any C99 complaint compiler, such as MSVC 2015+, GCC, Clang, etc.

	\subsection section_features What can FPL do?
	Read ahead a detailed feature overview of FPL:

	- Window
		- Create and handle a Single Window
		- Fullscreen toggling
		- Event handling
		- Clipboard string reading and writing
	- Event-based input
		- Text input
		- Keyboard
		- Mouse
		- Game Controllers
	- Video:
		- Driver selection
		- OpenGL 1.x (Legacy)
		- OpenGL 3.x or higher (Modern)
		- Software Backbuffer
	- Audio:
		- Driver selection
		- Raw audio asyncronous playback
		- Device iteration and selection
	- Memory
		- Allocation and De-allocation
		- Custom Alignment functions
		- Fast Clear/Set and Copy
	- Atomics
		- Support for 8,16,32,64 bit signed and unsigned integer types
		- Support for void pointer type
		- Compare and Exchange (CAS)
		- Add / Exchange
		- Load / Store
		- Memory Barriers
	- Shared library
		- Loading of Shared Libraries (DLL on Windows, .so on Linux/Unix)
		- Function Pointer Lookup
	- IO
		- Path functions
			- Query User Home Directory
			- Query Executable Path
			- Extract Filename, Extension and Path
			- Combine Paths
			- Change File Extension
		- Files/Directories
			- Reading and Writing of Binary Files (32-bit only, 64-bit are planned)
			- Iterating over Files/Directories
			- Rename/Copy/Delete/Move operations
	- Hardware infos retrievement
		- Query Processor Infos (Core Count, Name)
		- Query Current Memory State (Physical size, Virtual Size, Page Size, etc.)
		- Query System Architecture
	- OS infos retrievement
		- Query loggedin Username
		- Query OS Infos (Name, Version)
	- Timings
		- Get number of seconds (Low and High precision) used for profiling and delta calculations
		- Get number of milliseconds (Low and High precision) user for simple measurement
	- String conversion functions
		- Ansistring <-> Widestring
		- UTF-8 <-> Widestring
		- Copy
		- Comparing
		- Formatting
	- Console
		- Standard/Error out
		- Formatted out
		- Char input
	- Threading
		- Threads
		- Mutexes
		- Signals
		- Condition-Variables

	\subsection section_getstarted How do i get started with FPL?
	- You download the latest <a href="https://github.com/f1nalspace/final_game_tech/blob/master/final_platform_layer.h">"final_platform_layer.h"</a> file.
	- Drop it into your C/C++ project and use it in any place you want.
	- Define <b>FPL_IMPLEMENTATION</b> in at least one translation unit before including this header file!
	- Ready to go.

	For more details see the pages: \subpage page_usage / \subpage page_tutorials / \subpage page_examples.
*/

/*!
	\page page_usage Usage
	\tableofcontents

	\section section_usage How to use FPL?
	In one of your C/C++ translation units include this:

	\code{.c}
	#define FPL_IMPLEMENTATION
	#include "final_platform_layer.h"
	\endcode

	You can then include this file in any other C/C++ source or header file as you would with any other header file.

	Provide the typical main entry point with at least the initialization and release of the platform:

	\code{.c}
	int main(int argc, char **args) {
		// Initialize the platform
		if (fplPlatformInit(fplInitFlags_All, fpl_null)) {

			// your code goes here

			// Release the platform
			fplPlatformRelease();
			return 0;
		} else {
			return -1;
		}
	}
	\endcode

	\section subsection_usage_multiple_translation_units How to use FPL in multiple translation units?

	To use FPL in multiple translation units, i recommend creating a separated "final_platform_layer.c" in the same directory FPL is located and define the implementation there only:<br>

	<b>final_platform_layer.c</b>:
	\code{.c}
	#define FPL_IMPLEMENTATION
	#include "final_platform_layer.h"
	\endcode

	This way FPL implementation is compiled once and can be used everywhere.<br>

	\section subsection_usage_static_library How to use FPL in a static library?

	To use FPL in or as a static library, i recommend creating a separated translation unit for that but with disabled entry point inclusion:

	<b>final_platform_layer.c</b>:
	\code{.c}
	#define FPL_IMPLEMENTATION
	#define FPL_NO_ENTRYPOINT // Disable any entry point inclusions
	#include "final_platform_layer.h"
	\endcode

	This way FPL implementation is compiled in the static library properly and can be used by just including the static library and include the header file only.<br>

	\section subsection_usage_requirements What do i need to get started?
	The only dependencies are built-in operating system libraries and a C99 complaint compiler.<br>
	Depending on the compiler and platform - linking to one system library may be required:
	<br>
	\subsection subsection_usage_win32 Win32
	- Link against "kernel32.lib"

	\subsection subsection_usage_linux Linux
	- Link against "libld.so"

	\subsection subsection_usage_nocrt No C-Runtime
	By default FPL uses the C-Run-Time library but its usage is optional.<br>
	For more details see the page \subpage page_nocrt

	\section subsection_usage_options Options
	See \subpage page_compiler_options for all compile time options.
*/



/*!
	\page page_tutorials Tutorials
	\tableofcontents

	\section section_official_tutorials Official tutorials

	\subsection subsection_otutorial_general General
	\subpage page_otutorial_initialization <br>

	\subsection subsection_otutorial_window Window
	\subpage page_otutorial_window_creation <br>
	\subpage page_otutorial_window_events <br>

	\subsection subsection_otutorial_input Input
	\subpage page_otutorial_input_events <br>

	\subsection subsection_otutorial_threading Multithreading
	\subpage page_otutorial_threading_threads <br>
	\subpage page_otutorial_threading_mutexes <br>
	\subpage page_otutorial_threading_signals <br>
	\subpage page_otutorial_threading_conditions <br>
	\subpage page_otutorial_threading_sync <br>

	\subsection subsection_otutorial_video Video
	\subpage page_otutorial_video_general <br>
	\subpage page_otutorial_video_legacy_opengl <br>
	\subpage page_otutorial_video_modern_opengl <br>
	\subpage page_otutorial_video_software <br>

	\subsection subsection_otutorial_audio Audio
	\subpage page_otutorial_audio_general <br>
	\subpage page_otutorial_audio_writesamples <br>
*/

/*!
	\page page_otutorial_initialization Initialization & Release
	\tableofcontents

	\section section_otutorial_initialization_include Include the Library

	In one of your C/C++ translation units include this:

	\code{.c}
	#define FPL_IMPLEMENTATION
	#include "final_platform_layer.h"
	\endcode

	You can then include this file in any other C/C++ source or header file as you would with any other header file.

	\section section_otutorial_initialization_entrypoint Entry Point

	Simply provide the typical main entry point:<br>

	\code{.c}
	int main(int argc, char **args) {
		// code goes here
	}
	\endcode

	\section section_otutorial_initialization_simple Initialization

	To initialize FPL you need to call \ref fplPlatformInit() (inside the main \ref section_otutorial_initialization_entrypoint) and provide the desired \ref fplInitFlags and either NULL or a pointer as settings parameter:

	\code{.c}
	int main(int argc, char **args) {
		// With defaults (Window, Video, Audio)
		fplPlatformInit(fplInitFlags_All, fpl_null);

		// Only audio
		fplPlatformInit(fplInitFlags_Audio, fpl_null);

		// Only window and audio
		fplPlatformInit(fplInitFlags_Window | fplInitFlags_Audio, fpl_null);

		return 0;
	}
	\endcode

	Is is recommend to always pass a settings parameter, but it uses default when passing NULL as well.<br>
	To initialize a settings container to default values you simply call \ref fplSetDefaultSettings() with a pointer to your local settings container.

	\section section_otutorial_initialization_with_settings Initialization with custom settings

	To initialize FPL with custom settings you need to call \ref fplPlatformInit() and provide the desired \ref fplInitFlags and the \ref fplSettings parameter:

	\code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);

	// change the settings here

	fplPlatformInit(fplInitFlags_All, &settings);
	\endcode

	\section section_otutorial_initialization_release Release

	When you are done, you release FPL with the call \ref fplPlatformRelease():
	\code{.c}
	fplPlatformRelease();
	\endcode

	\section section_otutorial_initialization_result Result/Error checking

	There is no guarantee that \ref fplPlatformInit() will always work with the fplSettings you specified, maybe the audio device does not support a sample rate of 1337 Khz or your video card does not support OpenGL version 3.7 - who knows.<br>
	<br>
	Therefore you should always check the result of the \ref fplPlatformInit() call!<br>
	The result is a \ref fplInitResultType enum which is fplInitResultType_Success when initialization succeeded.<br>
	You can cast the result type to bool, so you can simply use it as a condition.<br>
	<br>
	Also you should release the platform when the initialization was successful only!<br>
	If something goes wrong the remaining resources are already cleaned up by FPL automatically.<br>
	<br>
	In addition you should use \ref fplGetPlatformError() to print out the actual error when the initialization fails!<br>

	<b>Bad:</b> (But will work)
	\code{.c}
	if (fplPlatformInit(fplInitFlags_All, fpl_null)) {
		// your code here
	}
	fplPlatformRelease();
	\endcode

	<b>Good:</b>
	\code{.c}
	if (fplPlatformInit(fplInitFlags_All, fpl_null)) {
		// your code here
		fplPlatformRelease();
	}
	\endcode

	<b>Better:</b>
	\code{.c}
	if (fplPlatformInit(fplInitFlags_All, fpl_null)) {
		// your code here
		fplPlatformRelease();
	} else {
		const char *errStr = fplGetPlatformError();
		fplConsoleFormatError("FPL-ERROR: %s\n", errStr);
	}
	\endcode

	<b>Even Better:</b>
	\code{.c}
	fplInitResultType initResult;
	if ((initResult = fplPlatformInit(fplInitFlags_All, fpl_null)) == fplInitResultType_Success) {
		// your code here
		fplPlatformRelease();
	} else {
		const char *errStr = fplGetPlatformError();
		const char *initResultStr = fplGetInitResultTypeString(initResult);
		fplConsoleFormatError("FPL-ERROR[%s]: %s\n", initResultStr, errStr);
	}
	\endcode

	See the \subpage page_otutorial_errorhandling page for more details about error handling.

	\section section_otutorial_initialization_tips Tips
	After releasing FPL you can call \ref fplPlatformInit() again if needed - for example: Finding the proper audio device, Testing for OpenGL compability, etc. may require you call \ref fplPlatformInit() and \ref fplPlatformRelease() multiple times.
*/

/*!
	\page page_otutorial_errorhandling Error handling
	\tableofcontents

	\section section_otutorial_errorhandling_getlatest Get latest error

	In case something goes wrong you can always call \ref fplGetPlatformError() - at any time, regardless if it is initialized or not.<br>
	This either returns a empty string indicating everything is fine or a constant string with a valid error message.<br>

	Example:
	\code{.c}
	const char *errStr = fplGetPlatformError();
	// Do something with the error string
	\endcode

	\section section_otutorial_errorhandling_count Was there a error?

	If you just want to check if there was an error, you can call \ref fplGetPlatformErrorCount() to use the number of errors as a condition.<br>

	Example:
	\code{.c}
	if (fplGetPlatformErrorCount()) {
		// Print out the error message
	}
	\endcode

	\section section_otutorial_errorhandling_clear Clearing the errors

	Errors will never be cleared by FPL! You have to do this yourself using \ref fplClearPlatformErrors() .<br>

	Example:
	\code{.c}
	fplClearPlatformErrors();
	\endcode

	\section section_otutorial_errorhandling_note Note
	Keep in mind that any platform error is reported in the output of the error console automatically!<br>
	If you dont want to do that, then simply define the preprocessor directive for ignoring this behavior - before including this library with implementation enabled:

	\code{.c}
	#define FPL_NO_ERROR_IN_CONSOLE
	#define FPL_IMPLEMENTATION
	#include <final_platform_layer.h>
	\endcode
*/

/*!
	\page page_otutorial_window_creation Window creation & main loop
	\tableofcontents

	\section section_otutorial_window_creation_init Initialization

	To create a window you add the \ref fplInitFlags_Window flag to the \ref fplInitFlags parameter in the \ref fplPlatformInit() call.<br>
	It makes no sense to create a window alone, so we combine it at least with something else, like for example: a video context or audio playback.<br>

	\code{.c}
	fplPlatformInit(fplInitFlags_Window | fplInitFlags_Video, fpl_null);
	\endcode

	\section section_otutorial_window_creation_loop Main loop

	After you initialize FPL with a window you have to create some sort of a loop to keep the window open until you close them.<br>
	This is required due to the fact that operating systems uses a event-based system to communicate with the window and your app.<br>
	If no communication happens with your window and your app, the window will no longer be responsive - so make sure to communicate properly.<br>
	<br>
	For that there is a single function call required to process these events -> \ref fplWindowUpdate().

	\code{.c}
	while (fplWindowUpdate()) {
		// your code goes here
	}
	\endcode

	\section section_otutorial_window_creation_note Note
	All window based calls are required to be executed from the main-thread only!

*/

/*!
	\page page_otutorial_window_events Window events
	\tableofcontents

	\section section_otutorial_window_events_polling Polling the events

	To poll the events from the internal queue you simply call the correspondending function \ref fplPollEvent() in a while-loop inside your actual main-loop.<br>
	Each event is copied into the \ref fplEvent parameter which you can handle or not.<br>
	If there are no events left, the function returns false and you are done.

	\code{.c}
	fplEvent currentEvent;
	while (fplPollEvent(&currentEvent)) {
		// ... Handling the event
	}
	\endcode

	\section section_otutorial_window_events_handling Handling the Events

	Each event has a \ref fplEvent.type field which you can check on to read the actual data (Keyboard, Mouse, Window, etc.).

	\code{.c}
	fplEvent currentEvent;
	while (fplPollEvent(&currentEvent)) {
		switch (currentEvent.type) {
			case fplEventType_Window:
			{
				// A window event, like resize, lost/got focus, etc.
			} break;
			case fplEventType_Keyboard:
			{
				// A keyboard event, like key down/up, pressed, etc.
			} break;
			case fplEventType_Mouse:
			{
				// A mouse event, like mouse button down/up, mouse move, etc.
			} break;
			case fplEventType_Gamepad:
			{
				// A gamepad event, like connected/disconnected, state-updated etc.
			} break;
		}
	}
	\endcode

	All available event types are stored in the \ref fplEventType enumeration.

	\section section_otutorial_window_events_handle_event_type Handle the event data

	All relevant event data are stored in fields which matches the lowercase \ref fplEventType name.<br>
	Each event structure has another type field to check for the actual type (Key-Down, Mouse-Move, Window-Resize etc.).<br>

	\subsection subsection_otutorial_window_events_handle_event_type_mouse Mouse events

	Mouse event data are stored in the \ref fplMouseEvent structure.

	\code{.c}
	switch (currentEvent.mouse.type) {
		case fplMouseEventType_ButtonDown:
		{
			fplMouseButtonType button = currentEvent.mouse.button;
			// ... do something with the mouse button
		} break;

		case fplMouseEventType_Move:
		{
			int mouseX = currentEvent.mouse.mouseX;
			int mouseY = currentEvent.mouse.mouseY;
			// ... do something with the mouse position
		} break;
	}
	\endcode

	\subsection subsection_otutorial_window_events_handle_event_type_keyboard Keyboard events

	Keyboard event data are stored in the \ref fplKeyboardEvent structure.<br>
	<br>
	You can either check for the original \ref fplKeyboardEvent.keyCode or use the fplKeyboardEvent.mappedKey field - which is much easier and less error prone.<br>

	\code{.c}
	switch (currentEvent.keyboard.type) {
		case fplKeyboardEventType_KeyDown:
		{
			// ... Handle the key code
			uint64_t keyCode = currentEvent.keyboard.keyCode;
			if (keyCode == 65 || keyCode == 97) {
				// Letter A is held down
			}

			// or

			// ... handle the mapped key
			fplKey mappedKey = currentEvent.keyboard.mappedKey;
			if (mappedKey == fplKey_F1) {
				// F1 key held down
			}
		} break;

		case fplKeyboardEventType_CharInput:
		{
			// Handle character input
		} break;
	}
	\endcode

	\subsection subsection_otutorial_window_events_handle_event_type_gamepad Gamepad events

	Gamepad event data are stored in the \ref fplGamepadEvent structure.<br>

	\code{.c}
	switch (currentEvent.gamepad.type) {
		case fplGamepadEventType_Connected:
		{
			// New gamepad device connected
		} break;

		case fplGamepadEventType_Disconnected:
		{
			// Lost connection to a gamepad device
		} break;

		case fplGamepadEventType_StateChanged:
		{
			// State of one controller updated (Buttons, Movement, etc.)
			if (absf(currentEvent.gamepad.leftStickX) > 0) {
				// ... Handle horizontal movement on left stick
			}
			if (currentEvent.gamepad.actionX.isDown) {
				// ... X-Button is held down
			}
		} break;
	}
	\endcode

	\subsection subsection_otutorial_window_events_handle_event_type_window Window events

	Window event data are stored in the \ref fplWindowEvent structure.<br>

	\code{.c}
	switch (currentEvent.window.type) {
		case fplWindowEventType_Resized:
		{
			uint32_t newWidth = currentEvent.window.width;
			uint32_t newHeight = currentEvent.window.height;
			// ... Window was resized, handle it properly
		} break;
	}
	\endcode

	\section section_otutorial_window_events_inotes Important Notes

	FPL does not cache the events from the previous update. If you dont handle the event - the data is lost!<br>
	You are responsible for caching the data if needed.<br>
	Also you must always poll each event to ensure that the internal queue will not get full!
*/

/*!
	\page page_otutorial_input_events Input events
	\tableofcontents

	\section section_page_otutorial_input_events_overview Overview

	All input events are mapped to window events.<br>
	To detect any key presses, button downs, you simply handle the specific event type in your event-loop!<br>
	<br>
	For details see the \subpage page_otutorial_window_events page.
*/

/*!
	\page page_otutorial_video_general Initialization & Overview
	\tableofcontents

	\section otutorial_video_general_init Initialize a video context

	To initialize either software or hardware video output you have to set the \ref fplInitFlags_Video flag in the \ref fplPlatformInit() call and ensure that video is not disabled by a preprocessor directive (FPL_NO_VIDEO).<br>

	Also setting the \ref fplInitFlags_Video flag ensures that the \ref fplInitFlags_Window flag is appended automatically.<br>

	\subsection otutorial_video_general_init_default Default video output

	If you dont specify any settings then the video driver is automatically detected, depending on your operating system and supported hardware and software.<br>
	By default this is most likely be legacy OpenGL - which is supported on almost every video card on any OS.<br>
	<br>
	But this is not the recommended way to initialize video output, due to the fact that you are responsible for handling any video output yourself.<br>

	\code{.c}
	if (fplPlatformInit(fplInitFlags_Video)) {
		// ... your code here
	}
	\endcode

	\subsection otutorial_video_general_init_setting_driver Setting the video driver

	It recommended to set at least the video driver manually, to ensure that you get either initialized with that driver properly or a error when your configuration is not supported.<br>
	<br>
	You do that by simply setting the \ref fplVideoDriverType field in your \ref fplVideoSettings structure which is included in the \ref fplSettings structure to the \ref fplPlatformInit() call.

	\code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplVideoSettings &videoSettings = settings.video;

	// Forcing the video driver to be OpenGL
	videoSettings.driver = fplVideoDriverType_OpenGL;

	if (fplPlatformInit(fplInitFlags_Video, &settings)) {
		// ... your code here
	}
	\endcode

	\section otutorial_video_general_vsync Enable/Disable Vertical Syncronisation

	If you want to enable/disable vertical syncronization you simply set the fplVideoSettings.isVSync field respectively.
	<br>
	\note There is no guarantee that vertical syncronisation is supported by your video device or selected driver.
	\note Software video output does not support vertical syncronisation!

	\section otutorial_video_general_disable Disable unneeded Video Drivers

	To compile out certain video drivers you simply specify the FPL_NO_VIDEO_[Name of the video driver] preprocessor directive.<br>
	But the correspondending \ref fplVideoDriverType is never removed from the enumeration - keep that in mind!<br>

	Example (Disable OpenGL Video Driver):

	\code{.c}
	#define FPL_NO_VIDEO_OPENGL
	#define FPL_IMPLEMENTATION
	#include <final_platform_layer.h>
	\endcode

	\section otutorial_video_general_disable_all Disable all Video Output

	To compile out all video output code you define the FPL_NO_VIDEO preprocessor directive.

	\code{.c}
	#define FPL_NO_VIDEO
	#define FPL_IMPLEMENTATION
	#include <final_platform_layer.h>
	\endcode

	\note Keep in mind that this is not useful for window based applications!
	\note If you writing a console application and dont want any video output whatsoever you set the FPL_NO_WINDOW which automatically disables any video devices as well.

	\section otutorial_video_general_notes Notes

	Driver types stored in the \ref fplVideoDriverType enumeration are not filtered away, even when you disable it by a preprocessor directive!<br>
	Keep that in mind when you initialize the video device.<br>

*/

/*!
	\page page_otutorial_video_legacy_opengl Legacy OpenGL
	\tableofcontents

	\section section_otutorial_video_legacy_opengl_init Initialize Legacy OpenGL

	To initialize a legacy OpenGL (up to GL version 2.1) rendering context you simply set the the \ref fplInitFlags_Video flag in the \ref fplPlatformInit() call and change the video driver type to \ref fplVideoDriverType_OpenGL and set the \ref fplOpenGLVideoSettings.compabilityFlags to \ref fplOpenGLCompabilityFlags_Legacy .<br>
	<br>
	This will work in ~99% on all supported platforms - if not please post a issue for that platform/configuration/video-card ;-)

	\code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplVideoSettings &videoSettings = settings.video;

	// Forcing the video driver to be legacy OpenGL
	videoSettings.driver = fplVideoDriverType_OpenGL;
	videoSettings.opengl.compabilityFlags = fplOpenGLCompabilityFlags_Legacy;

	if (fplPlatformInit(fplInitFlags_Video, &settings)) {
		// ... your code here
	}
	\endcode

	\section section_otutorial_video_legacy_opengl_usage Usage

	\subsection subsection_otutorial_video_legacy_opengl_usage_extensions Extensions loader

	To use features of OpenGL 1.2 or later you need some sort of a opengl extension loader which gives you access to the constants and functions like glMultiTexCoord2f().<br>
	For more details please check the modern OpenGL \ref subsection_otutorial_video_modern_opengl_usage_extensions section.

	\subsection subsection_otutorial_video_legacy_opengl_usage_present Presenting your frame

	To swap the backbuffer with the frontbuffer in the window you have to call the \ref fplVideoFlip() function.<br>
	Its recommend to call this after each draw call of your frame at the end of the main-loop.
*/

/*!
	\page page_otutorial_video_modern_opengl Modern OpenGL
	\tableofcontents

	\section section_otutorial_video_modern_opengl_init Initialize a modern OpenGL Rendering Context

	To initialize a modern OpenGL (3.0+) rendering context you simply set the the \ref fplInitFlags_Video flag in the \ref fplPlatformInit() call and change the video driver type to \ref fplVideoDriverType_OpenGL and setup the following parameters:<br>
	- Set the \ref fplOpenGLVideoSettings.majorVersion to 3 or higher
	- Set the \ref fplOpenGLVideoSettings.minorVersion to 0 or higher
	- Set the \ref fplOpenGLVideoSettings.compabilityFlags to either a \ref fplOpenGLCompabilityFlags_Core or \ref fplOpenGLCompabilityFlags_Compability
	- Optionally add the fplOpenGLCompabilityFlags_Forward flag for removing obsolete functions

	\code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplVideoSettings &videoSettings = settings.video;

	// Forcing the video driver to be modern OpenGL with Core profile and for GL version 3.3
	videoSettings.driver = fplVideoDriverType_OpenGL;
	videoSettings.opengl.compabilityFlags = fplOpenGLCompabilityFlags_Core;
	videoSettings.opengl.majorVersion = 3;
	videoSettings.opengl.minorVersion = 3;

	if (fplPlatformInit(fplInitFlags_Video, &settings)) {
		// ... modern context is ready
	}
	\endcode

	\section section_otutorial_video_modern_opengl_usage Usage

	\subsection subsection_otutorial_video_modern_opengl_usage_extensions Extensions loader

	To use modern OpenGL you need some sort of a opengl extension loader which gives you access to the constants and functions like glCreateProgram().<br>
	You can either use a thirdparty C/C++ library for doing that for you or use/write your own OpenGL loader. FPL should work in both ways.<br>
	<br>
	List of tested OpenGL loaders:
	- <a href="https://github.com/f1nalspace/final_game_tech/blob/master/final_dynamic_opengl.hpp">Final Dynamic OpenGL</a>
	- <a href="http://glew.sourceforge.net/">Glew</a>

	\subsection subsection_otutorial_video_modern_opengl_present Presenting your frame

	To swap the backbuffer with the frontbuffer in the window you have to call the \ref fplVideoFlip() function.<br>
	Its recommend to call this after each draw call of your frame at the end of the main-loop.

	\section section_otutorial_video_modern_opengl_notes Notes
	FPL does not provide any opengl types, prototypes or functions - its fully up to the caller how to handle this.
	<br>
	Keep in mind that FPL does not work with any OpenGL platform abstraction library like GLFW or GLUT!
*/

/*!
	\page page_otutorial_video_software Software Output
	\tableofcontents

	\section section_otutorial_video_software_init Initialize a Software Backbuffer

	FPL supports software video output as well, which will work on any platform.<br>

	\code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplVideoSettings &videoSettings = settings.video;

	// Forcing the video driver to be software
	videoSettings.driver = fplVideoDriverType_Software;

	if (fplPlatformInit(fplInitFlags_Video, &settings)) {
		// Video software back buffer is ready
		fplVideoBackBuffer *videoBackBuffer = fplGetVideoBackBuffer();
	}
	\endcode

	\section section_otutorial_video_software_usage Usage

	To use the software backbuffer you simply access the \ref fplVideoBackBuffer from the \ref fplGetVideoBackBuffer() function and update the pixels as needed.

	\subsection subsection_otutorial_video_software_present Presenting your frame

	To update the frontbuffer in the window with the pixels you may have changed you have to call the \ref fplVideoFlip() function.<br>
	Its recommend to call this after each draw call of your frame at the end of the main-loop.

	\subsection subsection_otutorial_video_software_drawing Drawing

	Drawing is done by manually changing the pixels in the \ref fplVideoBackBuffer.pixels field.<br>
	Each pixel is stored as 32-bit with 4 RGBA components in little-endian (AA BB GG RR).<br>
	Lines are stored in top-down order - meaning that position "0" in the \ref fplVideoBackBuffer.pixels field is always the top-left corner of the bitmap!<br>
	To calculate the actual position for the current line you simply multiply your Y-Index with the \ref fplVideoBackBuffer.lineWidth field.

	<b>Example (Filling all pixels to purple):</b>

	\code{.c}
	fplVideoBackBuffer *backBuffer = fplGetVideoBackBuffer();
	for (uint32_t y = 0; y < backBuffer->height; ++y) {
		uint32_t *p = (uint32_t *)((uint8_t *)backBuffer->pixels + y * backBuffer->lineWidth);
		for (uint32_t x = 0; x < backBuffer->width; ++x) {
			uint32_t color = 0xFFFF00FF;
			*p++ = color;
		}
	}
	\endcode

	\subsection subsection_otutorial_video_software_outrect Limiting the output rectangle (Stretching vs non-stretched)

	To force the pixels to be shown in a fixed rectangle you simply enable the \ref fplVideoBackBuffer.useOutputRect field and update the \ref fplVideoBackBuffer.outputRect as needed.<br>
	This mimics a "viewport" which is similar to OpenGLs glViewport().<br>
	<br>
	If you dont use this feature all pixels are fully stretched to the current window area always!

	\note This viewport should not be greater than the actual window area dimension!

	<b>Example (Resize window event):</b>
	\code{.c}
	fplVideoBackBuffer *backBuffer = fplGetVideoBackBuffer();
	backBuffer->useOutputRect = true;
	while (fplWindowUpdate()) {
		fplEvent ev;
		while (fplPollEvent(&ev)) {
			if (ev.type == fplEventType_Window) {
				if (ev.window.type == fplWindowEventType_Resized) {
					fplVideoRect newRect = ComputeLetterbox(ev.window.width, ev.window.height, backBuffer->width, backBuffer->height); // ... Compute new rectangle here (Letterbox or something)
					backBuffer->outputRect = newRect;
				}
			}
		}

		// ... Modify the pixels here (Draw call)

		fplVideoFlip();
	}
	\endcode

	<b>Example (Always before the draw call):</b>
	\code{.c}
	fplVideoBackBuffer *backBuffer = fplGetVideoBackBuffer();
	backBuffer->useOutputRect = true;
	while (fplWindowUpdate()) {
		fplEvent ev;
		while (fplPollEvent(ev)) {}

		fplWindowSize windowArea = fplGetWindowArea();
		fplVideoRect newRect = ComputeLetterbox(windowArea, backBuffer->width, backBuffer->height); // ... Compute new rectangle here (Letterbox or something)
		backBuffer->outputRect = newRect;

		// ... Modify the pixels here (Draw call)

		fplVideoFlip();
	}
	\endcode

	\subsection subsection_otutorial_video_software_resize Resizing the backbuffer

	By default the video backbuffer is automatically resized when the dimension of the window area changes.<br>
	If you want to manually do this, you disable this feature in the \ref fplVideoSettings.isAutoSize field - in the \ref fplSettings.video configuration section.<br>
	<br>
	To force the backbuffer to be resized to a fixed dimension you have to call \ref fplResizeVideoBackBuffer() with a new width and height.
	<br>
	\warning Do not call this method while you are modifing pixels!

	\section section_otutorial_video_software_notes Notes

	There is no software rendering functions built-in! If you want to draw for example a circle, you have to roll out your own drawCircle() function - which may uses Bresenham as its base or something.<br>
	Vertical syncronisation is not supported for software video drivers!
*/

/*!
	\page page_otutorial_audio_general Initialization & Usage
	\tableofcontents

	\section section_otutorial_audio_general_default_init Default initialization

	To initialize audio playback with default settings (Interleaved, 48 KHz, 2 Channels, signed 16-bit integer format) you have to set the \ref fplInitFlags_Audio flag in the \ref fplPlatformInit() call and ensure that audio is not disabled by a preprocessor directive (FPL_NO_AUDIO).<br>

	\code{.c}
	if (fplPlatformInit(fplInitFlags_Audio, fpl_null)) {
		// ... your code here
	}
	\endcode

	\subsection subsection_otutorial_audio_general_default_init_clientcallback Setting the client callback

	Next is to specify the client user callback which gets invoked regularly when the audio device requires new samples to play.<br>
	This \ref fpl_audio_client_read_callback "client callback" can be set up in the \ref fplAudioSettings.clientReadCallback field from the \ref fplSettings.audio or changed by calling \ref fplSetAudioClientReadCallback() :<br>

	\code{.c}
	static uint32_t MyAudioPlaybackCallback(const fplAudioDeviceFormat *nativeFormat, const uint32_t frameCount, void *outputSamples, void *userData) {
		// ... Fill audio frames here
	}

	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplAudioSettings &audioSettings = settings->audio;
	audioSettings.clientReadCallback = MyAudioPlaybackCallback;
	audioSettings.userData = // ... pointer to some user data
	if (fplPlatformInit(fplInitFlags_Audio, &settings)) {
		// ... your code here
	}
	\endcode

	\note This step must be done before you actually start playing the audio!
	\note You can specify a user data pointer which gets passed to the client callback as well.

	\section section_otutorial_audio_general_custom_init Custom initialization

	You can change several audio settings (Sample rate, Number of Channels, Format, etc.) before initializing the audio playback like this:<br>

	\code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplAudioSettings &audioSettings = settings.audio;
	audioSettings.clientReadCallback = MyAudioPlaybackCallback;
	audioSettings.userData = // ... pointer to some user data
	fplAudioDeviceFormat &audioDeviceFormat = audioSettings.deviceFormat;
	audioDeviceFormat.sampleRate = 48000;
	audioDeviceFormat.channels = 2;
	audioDeviceFormat.type = fplAudioFormatType_F32;
	if (fplPlatformInit(fplInitFlags_Audio, &settings)) {
		// ... your code here
	}
	\endcode

	\note Please see the \ref section_otutorial_audio_general_notes for possible limitations!

	\section section_otutorial_audio_general_choosing_driver Choosing the audio driver

	By default FPL uses the first available audio driver which is supported on your platform.<br>
	If you want to force FPL to use a certain audio driver, you can do this by changing the \ref fplAudioSettings.driver field in the \ref fplAudioSettings structure:<br>

	\code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplAudioSettings &audioSettings = settings.audio;

	// Forcing to use the DirectSound audio driver
	audioSettings.driver = fplAudioDriverType_DirectSound;

	if (fplPlatformInit(fplInitFlags_Audio, &settings)) {
		// ... your code here
	}
	\endcode

	Its recommend to use the default \ref fplAudioDriverType_Auto which uses the first supported audio driver.

	\warning If your platform/system does not support the desired driver the audio and platform initialization will fail!

	\section section_otutorial_audio_general_playing_and_stopping Start and stop playing the audio samples

	After the initialization the audio device is stopped always.<br>
	To start requesting and playing audio samples you have to call the \ref fplPlayAudio() function.<br>
	<br>
	To stop the audio playback you call the opposite \ref fplStopAudio() function.

	\note If you are about to release the platform using \ref fplPlatformRelease() you should always call \ref fplStopAudio() before!

	\section section_otutorial_audio_general_notes Notes

	There is no guarantee that you get the desired audio format you specified back!<br>
	You should always check the \ref fplAudioDeviceFormat "nativeAudioFormat" in your client callback and convert/write the correct samples the audio device expects!<br>
	<br>
	How to write samples is explained here: \subpage page_otutorial_audio_writesamples
*/

/*!
	\page page_otutorial_audio_writesamples Writing audio samples
	\tableofcontents

	\section section_otutorial_audio_writesamples_overview Overview

	To write audio samples in the audio client callback you have to know at least four things:
	- Target format (S16, S24, F32, etc.)
	- Target number of channels (1 = Mono, 2 = Stereo, etc.)
	- Target sample rate (44 KHz, 48 Khz, etc.)
	- Number of frames required

	All these informations are provided by the \ref fpl_audio_client_read_callback callback function.<br>
	<br>
	To get this information before the audio playback is started, you can query it by calling \ref fplGetAudioHardwareFormat() .

	\section section_otutorial_audio_writesamples_functions Useful functions

	To help with sample computation there are several inline functions available:

	- \ref fplGetAudioHardwareFormat()
	- \ref fplGetAudioBufferSizeInFrames()
	- \ref fplGetAudioDriverString()
	- \ref fplGetAudioFormatString()
	- \ref fplGetAudioSampleSizeInBytes()
	- \ref fplGetAudioFrameSizeInBytes()
	- \ref fplGetAudioBufferSizeInBytes()

	\section section_otutorial_audio_writesamples_s16 Writing 16-bit signed integer samples

	\code{.c}
	static uint32_t MyAudioPlaybackCallback(const fplAudioDeviceFormat *nativeFormat, const uint32_t frameCount, void *outputSamples, void *userData) {
		uint32_t result = 0;
		if (nativeFormat->type == fplAudioFormatType_S16) {
			int16_t *outSamples = (int16_t *)outputSamples;
			for (uint32_t frameIndex = 0; frameIndex < frameCount; ++frameIndex) {
				for (uint32_t channelIndex = 0; channelIndex < nativeFormat->channels; ++channelIndex) {
					*outSamples++ = // ... Getting a sample for the current frame/channel
					++result;
				}
			}
		} else {
			// ... handle other formats here
		}
		return result;
	}
	\endcode

	\section section_otutorial_audio_writesamples_notes Notes

	\note FPL does not provide any functionality for doing any kind of DSP or format conversion!<br>
	\note You are responsible for filling out the samples in the correct format your audio device expects!
*/

/*!
	\page page_otutorial_threading_threads Threads
	\tableofcontents

	\section section_otutorial_threading_threads_overview Overview
	In this section you will learn the Basics about creating and handling of Threads.<br>
	With Threads you can run multiple pieces of Code in parallel.<br>
	Threads require the use of \subpage page_otutorial_threading_sync to prevent race conditions.

	\section section_otutorial_threading_threads_create Creating a Thread
	To create a thread you call \ref fplThreadCreate() with a \ref fpl_run_thread_function "callback" and a user pointer passed as arguments.<br>
	This thread is automatically started and will run your user code almost immediatly.<br>

    \code{.c}
    void MyThreadProc(const fplThreadHandle *context, void *data) {
        // ... do something here
    }
    void RunMyThread() {
        int myData = 42;
        fplThread *thread = fplThreadCreate(MyThreadProc, &myData);
        fplThreadWaitForOne(thread, UINT32_MAX);
    }
    \endcode

	\note The internal Thread resources will be cleaned up automatically after your code has finished running.<br>
	\warning When a Thread has finished running you cannot use the same \ref fplThreadHandle anymore -> It may be reassigned to another Thread in the future.<br>

	\section section_otutorial_threading_threads_destroy Destroying a Thread?
	You dont have to manually release the Thread resources, this will be cleaned up automatically when either the Thread ends naturally or when it was terminated forcefully using \ref fplThreadTerminate() .
	<br>
	\warning Do not call \ref fplThreadTerminate() to stop or release a Thread! Let the thread exit naturally.

	\section section_otutorial_threading_threads_wait Waiting/Joining for Threads to Exit

	\subsection subsection_otutorial_threading_threads_wait_single Wait for a single Thread to Exit
	To wait for a single Thread to finish, you simply call \ref fplThreadWaitForOne() with the thread handle as argument and a timeout parameter.

	\code{.c}
	// Wait until the thread is finished
	fplThreadWaitForOne(thread, UINT32_MAX);

	// ... or

	// Wait at max for 5 seconds to finish the thread
	fplThreadWaitForOne(thread, 5000);
    \endcode

	\subsection subsection_otutorial_threading_threads_wait_any Wait for any Thread to Exit
	To wait until at least one Thread had finished you simply call \ref fplThreadWaitForAny() with a array of \ref fplThreadHandle , the number of threads and a timeout parameter.

	\code{.c}
	// Wait until one of the threads is finished
	fplThreadWaitForAny(threads, numOfThreads, UINT32_MAX);

	// ... or

	// Wait at max for 5 seconds to finish at least one of the threads
	fplThreadWaitForAny(threads, numOfThreads, 5000);
    \endcode

	\subsection subsection_otutorial_threading_threads_wait_all Wait for all Threads to Exit
	To wait for all Threads to be finished you simply call \ref fplThreadWaitForAll() with a array of \ref fplThreadHandle , the number of threads and a timeout parameter.

	\code{.c}
	// Wait until all of the threads are finished
	fplThreadWaitForAll(threads, numOfThreads, UINT32_MAX);

	// ... or

	// Wait at max for 5 seconds to finish all threads
	fplThreadWaitForAll(threads, numOfThreads, 5000);
    \endcode

	\section section_otutorial_threading_threads_terminate Terminate a thread
	Sometimes you need a way to forcefully terminate a thread. For this you can call \ref fplThreadTerminate() with the thread handle in question.
	<br>
	\note Using this will almost immediatly terminates the thread and releases its resources.
	\note It is safe to call this when a thread is already terminated.

	\section section_otutorial_threading_threads_states Query Thread State
	There is just one function to query the thread state -> \ref fplGetThreadState() .<br>
	If a thread is stopped or in the process of getting stopped it will return \ref fplThreadState_Stopped or \ref fplThreadState_Stopping respectively.<br>
	If a thread is started or in the process of getting started it will return \ref fplThreadState_Running or \ref fplThreadState_Starting respectively.<br>

	\section section_otutorial_threading_threads_notes Notes
	\note Your code should always ensure that it will exit eventually.<br>
	To ensure this there are several \subpage page_otutorial_threading_sync you can use to achieve this.<br>
	\note It is bad pratice to "Terminate" a thread, you should design your code to let threads end naturally.
*/

/*!
	\page page_otutorial_threading_mutexes Mutexes
	\tableofcontents

	\section section_otutorial_threading_mutexes_overview Overview
	This section explains how to create and handling of Mutexes.<br>
	A mutex is a Kernel-Level object used to prevent race conditions when multiple threads access the same data.<br>
	With a mutex you can ensure that only one thread at a time can access data.

	\section section_otutorial_threading_mutexes_init Initialize a Mutex
	To initialize a mutex you call \ref fplMutexInit() with a pointer to a \ref fplMutexHandle .
	After the initialization is done, you can start locking and unlocking it.<br>
	When you are done with the mutex call \ref fplMutexDestroy() to release its internal resources.

	\code{.c}
	fplMutexHandle mutex;
	if (!fplMutexInit(&mutex)) {
	    // Error: Mutex failed initializing -> Too many active mutexes for this process
	}

	// ... Mutex is not required anymore
	fplMutexDestroy(&mutex);
    \endcode

	\section section_otutorial_threading_mutexes_locking Locking/Unlocking a Mutex

	\subsection subsection_otutorial_threading_mutexes_locking_lock Locking a Mutex
	Locking a mutex is simply done by calling \ref fplMutexLock() .<br>
	If this mutex is not locked yet, it will be locked by the calling thread and the return value will be true.<br>
	It this mutex is already locked, the thread will wait forever until it gets unlocked by another thread and will return false.<br>
	<br>
	\note You should always unlock the \ref fplMutexHandle as soon as possible - on the same callstack.<br>

	\subsection subsection_otutorial_threading_mutexes_locking_unlock Unlocking a Mutex
	Unlocking is done by calling \ref fplMutexUnlock() .<br>
	The mutex will be unlocked when it was locked before and return true.<br>
	If the mutex was not locked, it will fail and return false in this case.

    \subsection subsection_otutorial_threading_mutexes_locking_example Example

	\code{.c}
	fplMutexLock(&mutex);
	{
	    // Do something with shared data here
	}
	fplMutexUnlock(&mutex);

	if (fplMutexLock(&mutex)) {
    	// Do something here as the "first" thread locking the mutex
	    fplMutexUnlock(&mutex);
	}
    \endcode

    \note It is recommend to put a opening/closing brace to mark the code inside the lock as critical code.
*/

/*!
	\page page_otutorial_threading_signals Signals
	\tableofcontents

	\section section_otutorial_threading_signals_overview Overview
	This section explains how to create and handling of Signals.<br>
	A signal is a Kernel-Level object used to notify one or multiple waiting threads.<br>
	It internally contains a Value which is either \ref fplSignalValue_Set or \ref fplSignalValue_Unset.<br>
	When this values gets changed, all threads which waits on that Signal will wakeup.<br>
	They can be shared across process boundaries and may be used as standalone locks to shared data, but the number of Signals are limited by the OS that can be allocated at a time.

	\section section_otutorial_threading_signals_init Initialize a Signal
	To initialize a Signal you just call \ref fplSignalInit() with a \ref fplSignalHandle as a argument.<br>
	Also you need to specify if the signal starts as \ref fplSignalValue_Set or \ref fplSignalValue_Unset as a second argument.<br>
	When you are done with that Signal you need to call \ref fplSignalDestroy() to release its internal resources.

	\code{.c}
	fplSignalHandle mutex;
	// Initialize a signal as "unset"
	if (!fplSignalInit(&mutex, fplSignalValue_Unset)) {
	    // Error: Signal failed initializing -> Too many active signals
	}

	// ... Signal is not required anymore
	fplSignalDestroy(&mutex);
    \endcode

	\section section_otutorial_threading_signals_waiting Waiting on a Signal
	To let one Thread to wait until a Signal is set, you simply call \ref fplSignalWaitForOne() with a \ref fplSignalHandle and a timeout as parameters.
*/

/*!
	\page page_otutorial_threading_conditions Condition-Variables
	\tableofcontents

	\section section_otutorial_threading_conditions_overview Overview
	This section explains how to create and handling of Condition-Variables.<br>
	A condition variable is a User-Level Object used to let threads wait until a condition variable is signaled or broadcasted.<br>
	Unlike Signals, Condition-Variables requires you to use a \ref fplMutexHandle as a locking mechanism.<br>
	They cannot be shared across process boundaries but the number of Condition-Variables is only limited by the amount of memory you have.

	\section otutorial_threading_conditions_init Initialize a Condition-Variable
	To initialize a Condition-Variable you just call \ref fplConditionInit() with a \ref fplConditionVariable as a argument.<br>
	When you are done with that Condition-Variable you need to call \ref fplConditionDestroy() to release its internal resources.

	\section otutorial_threading_conditions_wait_single Waiting on a Condition-Variable
	To let a thread wait on a Condition-Variable you simply call \ref fplConditionWait() with a \ref fplConditionVariable and a \ref fplMutexHandle as argument.
	Also you need to specify the amount of milliseconds you want the thread to wait. If UINT32_MAX is passed it will wait forever.<br>

	\section otutorial_threading_conditions_wait_multiple Waiting on multiple Condition-Variables?
	A thread can only wait on one single condition variable at a time - if you need to wait on multiple conditions, you should consider using \subpage page_otutorial_threading_signals .

	\section otutorial_threading_conditions_signal Signaling a Condition-Variable to one waiting Thread
	To signal a Condition-Variable to one single waiting Thread you need to call \ref fplConditionSignal() with the \ref fplConditionVariable in question.<br>
	If you want to let multiple threads waits on the same condition you should use \ref fplConditionBroadcast() instead.

	\section otutorial_threading_conditions_broadcast Signaling a Condition-Variable to all waiting Threads
	To broadcast a Condition-Variable to multiple waiting threads you need to call \ref  fplConditionBroadcast() with the \ref fplConditionVariable in question.<br>
	If you just need a single thread to wait on the condition you should use \ref fplConditionSignal() instead.
*/

/*!
	\page page_otutorial_threading_sync Syncronisation Methods
	\tableofcontents

	- TODO(final): Explain why we need this

	- TODO(final): Add examples of solving race conditions (Mutexes, Signals, Condition-Variables, Atomics)

	- TODO(final): Add a comparison table to show the difference between the object types.
*/

/*!
	\page page_faq FAQ
	\tableofcontents

	\section section_faq FAQ

	\subsection subsection_faq_license What are the license requirements for FPL?
	Final Platform Layer is released under the \subpage page_license "MIT License".<br>
	This license allows you to use FPL freely in any software.<br>

	\subsection subsection_faq_costs I did pay for FPL, did i get ripped-of?
	Yes you are! FPL is full open source and costs nothing.

	\subsection subsection_faq_inwhatlanguage In what language is FPL written?
	Final Platform Layer is written in C99 for simplicity and best portability, but is C++ compatible as well.<br>
	It uses default integral and boolean types <stdint.h> and <stdbool.h>.<br>
	For certain features such as printf(), getchar() the C Runtime are used, but you can disable it if needed.<br>
	It uses a fixed and small memory footprint and handles memory very gracefully.<br>

	\subsection subsection_faq_whyshouldiuse What makes it different from other platform abstraction libraries, such as SDL/SFML etc. ?
	- FPL is designed to require bare minimum linking to the OS (kernel32.lib / libld.so) only.
	- It does not require any dependencies or build-systems to get it running.
	- It has a lightweight feature set (Single window, Graphics api initialization, Raw audio samples playback, Input handling, Multithreading, Path/File IO, Atomics, OS/HW-Infos etc.)
	- No data hiding -> everything is accessible.
	- It uses a fixed and small memory footprint and handles memory very gracefully.
	- It can be controlled by a configuration structure in very detail at startup.
	- You decide how to integrate it; not the library

	\subsection subsection_faq_whyisfplsobig Why is FPL so big?
	Final Platform Layer contains headers and implementations for all supported platforms with all the function prototypes for linking operating system functions dynamically.<br>
	In addition there is a full detailed changelog included as well.<br>

	\subsection subsection_faq_limitations Does FPL have some limitations?
	Yes it does have some limitations, because it cannot do everything for you:
	- There is no audio DSP going on, so you have to convert the samples into the proper format (Sample rate, Channels, Format type) FPL expects.
	- There is no rendering functions included, except for presenting the current frame. So you have to load and call the correct api functions yourself.
	- FPL has a lightweight feature set, so it may miss some features

	\subsection subsection_faq_thirdparty_libs Can FPL handle third party libraries?
	Yes actually it works very well with other libraries - in fact there are several demo projects in the repository which shows that.<br>
	<br>
	Here is a short list of tested third-party libraries with FPL:

	- STB Libraries
	- Standard C++ Library (STL)
	- Glew/Glad
	- Box2D
	- GLM
	- ImGUI
	- FFMPEG

	But it wont work with other platform abstraction libraries such as SDL, SFML, GLUT, GLFW etc.<br>
	All these other platform abstraction libraries have their own way of providing the main entry point and are not compability with each other.
*/

/*!
	\page page_contribute Contribute
	\tableofcontents

	<b>I am happy that you want to support this project!</b><br>
	<br>
	I created and maintain this project alone, so i really appreciate any kind of contributions.<br>
	<br>
	There are several ways to help this project:<br>
	- Test the library for any hardware/platform/compiler configuration you have access to and report the result -> This helps a lot!
	- Report any bugs you find
	- Improving this documentation by sending in new tutorials/examples, point me to typos etc.
	- Send me pull-requests
	- Write new demos/samples/examples
	- Recommend this project to your collegues, friends, etc.
	- Send in feedback

	And lastly if you want to contact me for another reason, just drop a message in some way (Github issue, Private message, Mail, Community etc.).<br>
	<br>
	Thanks for using!<br>
*/

/*!
	\page page_examples Examples
	\tableofcontents

	\section section_console_examples Console examples

	- \subpage page_example_helloworld_console
	- \subpage page_example_simple_audio

	\section section_windowed_examples Window examples

	- \subpage page_example_opengl1x
	- \subpage page_example_opengl33
*/

/*!
	\page page_nocrt How to disable the use of the CRT in FPL
	\tableofcontents

	\section section_nocrt_consequences Consequences of disabling the CRT

	If you disable the CRT you lose a lot of functionality which we today take for granted:<br>

	- No functions from the entire C standard library stack, such as "stdio.h" / "stdlib", / "math.h" / "string.h", etc.
	- No or limited integer mul/div operations on some platforms
	- No console input/output
	- No C++ exceptions
	- Limited security checks
	- No automatic entry point mapping to main() or WinMain()
	- Limited floating point operations on some platforms
	- Limited stack size

	Some limitations can be corrected by setting up the compiler properly, such as stack size, security checks, etc.<br>
	<br>
	So if you are fine with that, the next section describes how to do disable the CRT usage in FPL.

	\section section_nocrt_requirements Requirements for disabling the CRT in FPL

	- You have read the \ref section_nocrt_consequences
	- You know what you are doing
	- You already disabled the CRT by compiler settings
	- You fixed the security checks and stack size by compiler settings

	\section bsection_nocrt_disableit Disable the CRT in FPL

	To disable the use of the C-Runtime Library you need to set certain preprocessor definitions:

	- Define FPL_NO_CRT in all translation units where FPL implementation is included
	- In your main translation unit you need to define the application type FPL_APPTYPE_CONSOLE or FPL_APPTYPE_WINDOW explicitly

	\code{.c}
	#define FPL_NO_CRT // Disable CRT support in FPL
	#define FPL_APPTYPE_CONSOLE // or FPL_APPTYPE_WINDOW
	#define FPL_IMPLEMENTATION // FPL_NO_CRT must be set set in the implementation only
	#include <final_platform_layer.h>
	\endcode

	\section section_nocrt_provfunccrt Providing intrinsics (Mini-CRT)

	Some compilers such as MSVC require certain stuff to compile properly.<br>
	You are responsible to provide that stuff if you get compile errors.<br>
	<br>
	A few errors you may get:

	Runtime check:
	- unresolved external symbol __RTC_Shutdown
	- unresolved external symbol __RTC_InitBase
	- unresolved external symbol __RTC_CheckEsp
	- unresolved external symbol __RTC_CheckStackVars

	Float:
	- unresolved external symbol __fltused -> Global used in MSVC
	- unresolved external symbol __ltod3 -> Double division intrinsic

	Integer:
	- unresolved external symbol __allmul -> Long-Long integer multiplication intrinsic

	Other:
	- unresolved external symbol __memset -> memset intrinsic (May use fplMemorySet)
	- unresolved external symbol __memcpy -> memcpy intrinsic (May use fplMemoryCopy)

	To solve this compile errors i recommend using a mini-crt library or write all the functions yourself.<br>
	<br>
	For more details see:<br>
	https://handmade.network/wiki/2824-tutorial_how_to_avoid_c_c++_runtime_on_windows

	\section section_nocrt_notes Notes

	Right know FPL have No-CRT support for Win32 only! If you need this for other platforms let me know.
*/

/*!
	\page page_compiler_options Compiler Options
	\tableofcontents

	\section section_compiler_options_preprocessor_opts Preprocessor options

	<table>
		<tr><th>Category</th><th>Macro definition</th><th>Description</th><th>Default</th></tr>

		<tr>
			<td>System</td>
			<td>FPL_IMPLEMENTATION</td>
			<td>
				Define this to include the actual implementation code.<br>
				Set this only once per translation unit, otherwise you will get linking errors.
			</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>System</td>
			<td>FPL_NO_ENTRYPOINT</td>
			<td>
				Define this to disable any entry point inclusion in the implementation.<br>
				This is useful when you use FPL in multiple translation units, but want your main entry point to be included only once.
			</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>System</td>
			<td>FPL_API_AS_PRIVATE</td>
			<td>
				Define this to make all functions be private ( <b>static</b> ).<br>
				This means that all function calls can be called from one translation unit only.
			</td>
			<td>By default all FPL functions are defined as ( <b>extern</b> )</td>
		</tr>
		<tr>
			<td>System</td>
			<td>FPL_DEBUG</td>
			<td>
				Define this to enable the "Debug" configuration.<br>
				When set assertions and some debug related features are enabled.
			</td>
			<td>By default this is auto-detected by compiler settings.</td>
		</tr>
		<tr>
			<td>System</td>
			<td>FPL_RELEASE</td>
			<td>
				Define this to enable the "Release" configuration.<br>
				When set all DEBUG features are compiled out entirely.
			</td>
			<td>By default this is auto-detected by compiler settings.</td>
		</tr>

		<tr>
			<td>Assertions</td>
			<td>FPL_NO_ASSERTIONS</td>
			<td>Define this to disable all internal assertions.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Assertions</td>
			<td>FPL_FORCE_ASSERTIONS</td>
			<td>Define this to enable internal assertions always, even in debug builds.</td>
			<td>
			Not set by default.<br>
			\note When enabled all assertions will use a simple null-pointer assertion macro always!
			</td>
		</tr>
		<tr>
			<td>Assertions</td>
			<td>FPL_NO_C_ASSERT</td>
			<td>Define this to disable C runtime assert.</td>
			<td>
			Not set by default.<br>
			\note Has no effect when FPL_FORCE_ASSERTIONS is set!
			</td>
		</tr>

		<tr>
			<td>Window</td>
			<td>FPL_NO_WINDOW</td>
			<td>Define this to disable window support entirely.</td>
			<td>Not set by default</td>
		</tr>

		<tr>
			<td>Video</td>
			<td>FPL_NO_VIDEO</td>
			<td>Define this to disable video support entirely.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Video</td>
			<td>FPL_NO_VIDEO_OPENGL</td>
			<td>Define this to disable the opengl video driver.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Video</td>
			<td>FPL_NO_VIDEO_SOFTWARE</td>
			<td>Define this to disable the software video driver.</td>
			<td>Not set by default</td>
		</tr>

		<tr>
			<td>Audio</td>
			<td>FPL_NO_AUDIO</td>
			<td>Define this to disable audio support entirely.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Audio</td>
			<td>FPL_NO_AUDIO_DIRECTSOUND</td>
			<td>Define this to disable directsound support entirely.</td>
			<td>Not set by default</td>
		</tr>

		<tr>
			<td>Error handling</td>
			<td>FPL_NO_MULTIPLE_ERRORSTATES</td>
			<td>Define this to use a single error state for \ref fplGetPlatformError() instead of multiple ones.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Error handling</td>
			<td>FPL_NO_ERROR_IN_CONSOLE</td>
			<td>Define this to disable printing any platform specific errors to the console.</td>
			<td>By default all platform specific error will be printed to the error console.</td>
		</tr>

		<tr>
			<td>C-Runtime</td>
			<td>FPL_NO_CRT</td>
			<td>Define this to disable the usage of functions from the CRT.</td>
			<td>This is not set by default.</td>
		</tr>

		<tr>
			<td>Application</td>
			<td>FPL_NO_APPTYPE</td>
			<td>Define this to disable the application type detection.</td>
			<td>By default this are not set and the application type is detected automatically.</td>
		</tr>
		<tr>
			<td>Application</td>
			<td>FPL_APPTYPE_CONSOLE</td>
			<td>Define this to force your application to be a console application.<br>When this is set the window support will be compiled out!</td>
			<td>By default this are set when FPL_NO_WINDOW is defined.</td>
		</tr>
		<tr>
			<td>Application</td>
			<td>FPL_APPTYPE_WINDOW</td>
			<td>Define this to force your application to be a windowed application.</td>
			<td>By default this are set when FPL_NO_WINDOW is _not_ defined.</td>
		</tr>

		<tr>
			<td>User functions</td>
			<td>FPL_USERFUNC_vsnprintf</td>
			<td>Define this to provide a replacement for vsnprintf() when FPL_NO_CRT is set.</td>
			<td>By default this is not set.</td>
		</tr>

	</table>	

	\section section_compiler_options_detection Platform/Compiler detection

	Like every other C/C++ program, FPL uses compiler defines to detect the proper platform/architecture and used compiler.<br>
	If you need this information for whatever reason you can simply compare the defines:

	- FPL_PLATFORM_WIN32 or FPL_PLATFORM_LINUX or FPL_PLATFORM_FREEBSD ...
	- FPL_ARCH_X64 or FPL_ARCH_X86 or FPL_ARCH_ARM64 ...

	All this defines have no value set, there are just "defined" - use always defined() for checking them.

	\code{.c}
	#if defined(FPL_PLATFORM_WIN32)
		// ... Any win32 code you may need
	#endif // FPL_PLATFORM_WIN32

	#if defined(FPL_ARCH_X64)
		// ... Any x64 code you may need
	#endif // FPL_ARCH_X64

	#if defined(FPL_COMPILER_MSVC)
		// ... MSVC compiler specific code you may need
	#endif // FPL_COMPILER_MSVC
	\endcode

	\section section_compiler_options_subplatform Sub-Platforms

	To prevent code duplication for platform combinations, FPL uses sub-platforms - which are no real platforms, but rather principles or standards the actual operating system is built-on.<br>
	For example "Linux" is detected as FPL_PLATFORM_LINUX but uses POSIX as a sub-platform FPL_SUBPLATFORM_POSIX.<br>
	Another example is "FreeBSD" which is a unix-based operation system which uses POSIX standards as well, so it uses the same posix sub platform.<br>
*/

/*!
	\page page_example_helloworld_console Hello World Console Application!
	\tableofcontents

	\section section_maincpp1 main.cpp

	\code{.c}
	#define FPL_IMPLEMENTATION
	#include "final_platform_layer.h"

	int main(int argc, char *args[]) {
		int result;
		if (fplPlatformInit(fplInitFlags_None)) {
			fplConsoleOut("Hello World!");
			fplPlatformRelease();
			result = 0;
		} else {
			result = -1;
		}
		return(result);
	}
	\endcode

*/

/*!
	\page page_example_opengl1x Simple OpenGL 1.x
	\tableofcontents

	\section section_maincpp2 main.cpp

	\code{.c}
	#define FPL_IMPLEMENTATION
	#include "final_platform_layer.h"

	// You have to include GL.h yourself or use any other opengl loader you want.
	// This library just creates a opengl rendering context for you, but nothing more.
	// GL.h will only be included when FPL_IMPLEMENTATION is set!
	#include <GL\GL.h>

	int main(int argc, char *args[]) {
		int result = 0;
		if (fplPlatformInit(fplInitFlags_Video, fpl_null)) {
			glClearColor(0.39f, 0.58f, 0.93f, 1.0f);
			while (fplWindowUpdate()) {
				fplWindowSize windowArea = fplGetWindowArea();
				glViewport(0, 0, windowArea.width, windowArea.height);
				glClear(GL_COLOR_BUFFER_BIT);
				glBegin(GL_TRIANGLES);
				glVertex2f(0.0f, 0.5f);
				glVertex2f(-0.5f, -0.5f);
				glVertex2f(0.5f, -0.5f);
				glEnd();
				fplVideoFlip();
			}
			fplPlatformRelease();
			result = 0;
		} else {
			result = -1;
		}
		return(result);
	}
	\endcode

*/

/*!
	\page page_example_opengl33 Modern OpenGL 3.3+
	\tableofcontents

	\section section_maincpp3 main.cpp

	\code{.c}
	#define FPL_IMPLEMENTATION
	#include "final_platform_layer.h"

	// You have to include GL.h yourself or use any other opengl loader you want.
	// This library just creates a opengl rendering context for you, but nothing more.
	// GL.h will only be included when FPL_IMPLEMENTATION is set!
	#include <GL\GL.h>

	int main(int argc, char *args[]) {
		int result = 0;

		// Legacy opengl is default, so we force it to be forward or backward compability
		fplSettings settings;
		fplSetDefaultSettings(&settings);
		settings.video.driver = fplVideoDriverType_OpenGL;
		settings.video.opengl.compabilityFlags = fplOpenGLCompabilityFlags_Core;
		settings.video.opengl.majorVersion = 3;
		settings.video.opengl.minorVersion = 3;
		if (fplPlatformInit(fplInitFlags_Video, &settings)) {
			glClearColor(0.39f, 0.58f, 0.93f, 1.0f);
			while (fplWindowUpdate()) {
				fplWindowSize windowArea = fplGetWindowArea();
				glViewport(0, 0, windowArea.width, windowArea.height);
				glClear(GL_COLOR_BUFFER_BIT);

				// Your code using modern opengl (VBO, IBO, VAO, GLSL, etc.)

				fplVideoFlip();
			}
			fplPlatformRelease();
			result = 0;
		} else {
			result = -1;
		}
		return(result);
	}
	\endcode

*/

/*!
	\page page_example_simple_audio Simple audio playback
	\tableofcontents

	\section section_maincpp4 main.cpp

	\code{.c}
	#define FPL_IMPLEMENTATION
	#define FPL_NO_WINDOW
	#include <final_platform_layer.h>
	#include <math.h> // sinf

	struct AudioTest {
		uint32_t toneHz;
		uint32_t toneVolume;
		uint32_t runningSampleIndex;
		uint32_t wavePeriod;
		bool useSquareWave;
	};

	static const float PI32 = 3.14159265359f;

	static uint32_t FillAudioBuffer(const fplAudioDeviceFormat *nativeFormat, const uint32_t frameCount, void *outputSamples, void *userData) {
		AudioTest *audioTest = (AudioTest *)userData;
		FPL_ASSERT(audioTest != nullptr);
		FPL_ASSERT(nativeFormat->type == fplAudioFormatType_S16);
		uint32_t result = 0;
		int16_t *outSamples = (int16_t *)outputSamples;
		uint32_t halfWavePeriod = audioTest->wavePeriod / 2;
		for (uint32_t frameIndex = 0; frameIndex < frameCount; ++frameIndex) {
			int16_t sampleValue;
			if (audioTest->useSquareWave) {
				sampleValue = ((audioTest->runningSampleIndex++ / halfWavePeriod) % 2) ? (int16_t)audioTest->toneVolume : -(int16_t)audioTest->toneVolume;
			} else {
				float t = 2.0f * PI32 * (float)audioTest->runningSampleIndex++ / (float)audioTest->wavePeriod;
				sampleValue = (int16_t)(sinf(t) * audioTest->toneVolume);
			}
			for (uint32_t channelIndex = 0; channelIndex < nativeFormat->channels; ++channelIndex) {
				*outSamples++ = sampleValue;
				++result;
			}
		}
		return result;
	}

	int main(int argc, char *args[]) {
		int result = -1;

		// Initialize to default settings which is 48 KHz and 2 Channels
		fplSettings settings;
		fplSetDefaultSettings(&settings);

		// Optionally overwrite audio settings if needed

		// Setup some state for the sine/square wave generation
		AudioTest audioTest = {};
		audioTest.toneHz = 256;
		audioTest.toneVolume = 1000;
		audioTest.wavePeriod = settings.audio.deviceFormat.sampleRate / audioTest.toneHz;
		audioTest.useSquareWave = false;

		// Provide client read callback and optionally user data
		settings.audio.clientReadCallback = FillAudioBuffer;
		settings.audio.userData = &audioTest;
		settings.audio.deviceFormat.type = fplAudioFormatType_S16;
		settings.audio.deviceFormat.channels = 2;
		settings.audio.deviceFormat.sampleRate = 48000;

		// Find audio device
		if (fplPlatformInit(fplInitFlags_Audio, &settings)) {
			fplAudioDeviceID audioDevices[16] = {};
			uint32_t deviceCount = fplGetAudioDevices(audioDevices, FPL_ARRAYCOUNT(audioDevices));
			if (deviceCount > 0) {
				settings.audio.deviceID = audioDevices[0];
				fplConsoleFormatOut("Using audio device: %s\n", settings.audio.deviceID.name);
			}
			fplPlatformRelease();
		}

		// Initialize the platform with audio enabled and the settings
		if (fplPlatformInit(fplInitFlags_Audio, &settings)) {
			// You can overwrite the client read callback and user data if you want to
			fplSetAudioClientReadCallback(FillAudioBuffer, &audioTest);
			// Start audio playback (This will start calling clientReadCallback regulary)
			if (fplPlayAudio() == fplAudioResult_Success) {
				// Print out the native audio format
				fplAudioDeviceFormat nativeFormat = fplGetAudioHardwareFormat();
				fplConsoleFormatOut("Audio with %lu KHz and %lu channels is playing, press any key to stop playback...\n", nativeFormat.sampleRate, nativeFormat.channels);
				// Wait for any key presses
				fplConsoleWaitForCharInput();
				// Stop audio playback
				fplStopAudio();
			}
			// Release the platform
			fplPlatformRelease();
			result = 0;
		}
		return(result);
	}
	\endcode

*/

/*!
	\page page_license License
	\tableofcontents

	\section section_mit_license MIT License

	Copyright (c) 2017-2018 Torsten Spaete<br>
	<br>
	Permission is hereby granted, free of charge, to any person obtaining a copy of<br>
	this software and associated documentation files (the "Software"), to deal in<br>
	the Software without restriction, including without limitation the rights to<br>
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies<br>
	of the Software, and to permit persons to whom the Software is furnished to do<br>
	so, subject to the following conditions:<br>
	<br>
	The above copyright notice and this permission notice shall be included in all<br>
	copies or substantial portions of the Software.<br>
	<br>
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br>
	SOFTWARE.<br>
*/